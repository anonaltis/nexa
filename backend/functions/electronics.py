"""
Electronics Domain Tools provided to the Gemini Agent.
"""
import logging
import math

logger = logging.getLogger(__name__)

def calculate_resistor_value(voltage_source: float, forward_voltage: float, current_ma: float) -> dict:
    """
    Calculate the required resistor value for an LED or component.
    
    Args:
        voltage_source: Source voltage in Volts (e.g., 5.0, 3.3, 12.0)
        forward_voltage: Component forward voltage drop in Volts (e.g., 2.0 for Red LED)
        current_ma: Desired current in milliAmps (e.g., 20.0)
        
    Returns:
        dict: Calculated resistance, nearest standard values, and power rating.
    """
    try:
        if current_ma <= 0:
            return {"error": "Current must be greater than 0"}
            
        current_a = current_ma / 1000.0
        voltage_drop = voltage_source - forward_voltage
        
        if voltage_drop < 0:
            return {
                "error": f"Source voltage ({voltage_source}V) is lower than forward voltage ({forward_voltage}V)"
            }
            
        resistance = voltage_drop / current_a
        power_w = voltage_drop * current_a
        
        # Standard E12 resistor values
        e12_scale = [10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82]
        multiplier = 10 ** math.floor(math.log10(resistance) if resistance > 0 else 0)
        
        # Find nearest standard values
        # This is a simple approximation
        nearest_standard = round(resistance) 
        
        return {
            "calculated_resistance_ohms": round(resistance, 2),
            "nearest_standard_value_suggestion": f"{nearest_standard} ohms (Verify with E12/E24 series)",
            "power_dissipation_watts": round(power_w, 4),
            "recommended_power_rating": "1/4 Watt" if power_w < 0.25 else "1/2 Watt or higher"
        }
    except Exception as e:
        logger.error(f"Error calculating resistor: {e}")
        return {"error": str(e)}

def search_component_datasheet(component_name: str) -> dict:
    """
    Simulated search for component datasheets and specs.
    In a real app, this would query an API like Octopart or DigiKey.
    
    Args:
        component_name: Name of the component (e.g., "ESP32", "LM7805", "2N2222")
    """
    # Mock database of common components for demonstration
    common_components = {
        "esp32": {
            "description": "Wi-Fi + Bluetooth + BLE MCU module",
            "operating_voltage": "3.3V (Absolute Max 3.6V)",
            "logic_level": "3.3V",
            "notes": "Requires good power supply. GPIOs are NOT 5V tolerant."
        },
        "arduino uno": {
            "description": "ATmega328P based microcontroller board",
            "operating_voltage": "5V",
            "logic_level": "5V",
            "notes": "Robust for beginners."
        },
        "lm7805": {
            "description": "5V Positive Voltage Regulator",
            "input_voltage": "7V - 25V",
            "output_voltage": "5V",
            "notes": "Needs capacitors on input and output. Heats up with high load."
        },
        "dht11": {
            "description": "Temperature and Humidity Sensor",
            "operating_voltage": "3.3V - 5.5V",
            "notes": "Slow sampling rate (1Hz)."
        },
         "dht22": {
            "description": "Temperature and Humidity Sensor (Higher accuracy than DHT11)",
            "operating_voltage": "3.3V - 6V",
            "notes": "Good for most environmental monitoring."
        },
        "hc-sr04": {
             "description": "Ultrasonic Distance Sensor",
             "operating_voltage": "5V",
             "notes": "Logic is 5V. Use voltage divider for 3.3V MCUs like ESP32."
        }
    }
    
    key = component_name.lower().strip()
    # Simple partial match
    for k, v in common_components.items():
        if k in key or key in k:
            return {
                "component": k.upper(),
                "specs": v,
                "found": True
            }
            
    return {
        "found": False,
        "message": f"Specs for '{component_name}' not found in local database. Please proceed with general knowledge but verify voltages."
    }

def generate_circuit_diagram_mermaid(components: list[str]) -> str:
    """
    Generates a Mermaid.js circuit diagram syntax based on components.
    This is a helper to format the output.
    """
    graph = "graph TD\n"
    graph += "    %% Circuit Diagram generated by Agent\n"
    
    # Just a placeholder generator - the LLM does better at this directly, 
    # but having a function encourages it to think about structure.
    for i, comp in enumerate(components):
        graph += f"    C{i}[{comp}]\n"
        
    return graph
