
import os
import json
from typing import Optional, List, Dict, Any
from google import genai
from dotenv import load_dotenv

load_dotenv()

# Load system prompt
PROMPT_PATH = os.path.join(os.path.dirname(__file__), "..", "prompts", "code_generation.md")
with open(PROMPT_PATH, "r") as f:
    SYSTEM_PROMPT = f.read()

# Initialize Gemini client
GENAI_API_KEY = os.getenv("GEMINI_API_KEY")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
client = None

if GENAI_API_KEY and GENAI_API_KEY != "MOCK":
    try:
        client = genai.Client(api_key=GENAI_API_KEY, http_options={'api_version': 'v1'})
    except Exception as e:
        print(f"Failed to initialize Gemini client: {e}")
elif GOOGLE_API_KEY:
    try:
        client = genai.Client(api_key=GOOGLE_API_KEY, http_options={'api_version': 'v1'})
    except Exception as e:
        print(f"Failed to initialize Gemini client: {e}")

MODEL_NAME = "gemini-2.5-flash-lite"

# Board templates for quick starts
BOARD_TEMPLATES = {
    "esp32": {
        "name": "ESP32",
        "default_pins": {
            "i2c_sda": 21,
            "i2c_scl": 22,
            "spi_mosi": 23,
            "spi_miso": 19,
            "spi_sck": 18,
            "spi_cs": 5,
            "uart_tx": 17,
            "uart_rx": 16,
            "adc": [32, 33, 34, 35, 36, 39],
            "dac": [25, 26],
            "pwm": list(range(0, 40))  # Most GPIO support PWM
        },
        "features": ["WiFi", "Bluetooth", "BLE", "Dual Core", "240MHz", "520KB SRAM"],
        "frameworks": ["Arduino", "ESP-IDF", "MicroPython"]
    },
    "esp8266": {
        "name": "ESP8266",
        "default_pins": {
            "i2c_sda": 4,  # D2
            "i2c_scl": 5,  # D1
            "spi_mosi": 13,
            "spi_miso": 12,
            "spi_sck": 14,
            "spi_cs": 15,
            "uart_tx": 1,
            "uart_rx": 3,
            "adc": [0],  # A0 only
            "pwm": [0, 2, 4, 5, 12, 13, 14, 15]
        },
        "features": ["WiFi", "80MHz/160MHz", "80KB SRAM"],
        "frameworks": ["Arduino", "NodeMCU", "MicroPython"]
    },
    "arduino-uno": {
        "name": "Arduino Uno",
        "default_pins": {
            "i2c_sda": "A4",
            "i2c_scl": "A5",
            "spi_mosi": 11,
            "spi_miso": 12,
            "spi_sck": 13,
            "spi_cs": 10,
            "uart_tx": 1,
            "uart_rx": 0,
            "adc": ["A0", "A1", "A2", "A3", "A4", "A5"],
            "pwm": [3, 5, 6, 9, 10, 11]
        },
        "features": ["ATmega328P", "16MHz", "2KB SRAM", "32KB Flash"],
        "frameworks": ["Arduino"]
    },
    "arduino-nano": {
        "name": "Arduino Nano",
        "default_pins": {
            "i2c_sda": "A4",
            "i2c_scl": "A5",
            "spi_mosi": 11,
            "spi_miso": 12,
            "spi_sck": 13,
            "spi_cs": 10,
            "uart_tx": 1,
            "uart_rx": 0,
            "adc": ["A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7"],
            "pwm": [3, 5, 6, 9, 10, 11]
        },
        "features": ["ATmega328P", "16MHz", "2KB SRAM", "32KB Flash", "Compact"],
        "frameworks": ["Arduino"]
    },
    "raspberry-pi-pico": {
        "name": "Raspberry Pi Pico",
        "default_pins": {
            "i2c_sda": 0,
            "i2c_scl": 1,
            "spi_mosi": 3,
            "spi_miso": 4,
            "spi_sck": 2,
            "spi_cs": 5,
            "uart_tx": 0,
            "uart_rx": 1,
            "adc": [26, 27, 28],
            "pwm": list(range(0, 29))
        },
        "features": ["RP2040", "Dual Core ARM", "133MHz", "264KB SRAM"],
        "frameworks": ["Arduino", "MicroPython", "C/C++ SDK"]
    }
}

# Mock code for fallback
MOCK_CODE_RESPONSE = {
    "files": [
        {
            "filename": "main.ino",
            "language": "arduino",
            "content": '''/*
 * Smart Temperature Monitor
 * Generated by ElectroLab AI
 *
 * Hardware:
 * - ESP32 DevKit v1
 * - DHT22 Sensor (GPIO4)
 * - OLED Display (I2C: GPIO21, GPIO22)
 */

#include <WiFi.h>
#include <DHT.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Pin Definitions
#define DHTPIN 4
#define DHTTYPE DHT22

// WiFi Credentials
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// OLED Display
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// DHT Sensor
DHT dht(DHTPIN, DHTTYPE);

void setup() {
  Serial.begin(115200);

  // Initialize DHT sensor
  dht.begin();

  // Initialize OLED display
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println(F("ElectroLab"));
  display.println(F("Temperature Monitor"));
  display.display();
  delay(2000);
}

void loop() {
  // Read sensor data
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();

  // Check if read failed
  if (isnan(humidity) || isnan(temperature)) {
    Serial.println(F("Failed to read from DHT sensor!"));
    return;
  }

  // Display readings
  display.clearDisplay();
  display.setCursor(0, 0);
  display.setTextSize(1);
  display.println(F("Temperature Monitor"));
  display.println();
  display.setTextSize(2);
  display.print(temperature, 1);
  display.println(F(" C"));
  display.print(humidity, 1);
  display.println(F(" %"));
  display.display();

  // Print to Serial
  Serial.print(F("Temperature: "));
  Serial.print(temperature);
  Serial.print(F(" C, Humidity: "));
  Serial.print(humidity);
  Serial.println(F(" %"));

  delay(2000);
}'''
        },
        {
            "filename": "config.h",
            "language": "cpp",
            "content": '''#ifndef CONFIG_H
#define CONFIG_H

// WiFi Settings
#define WIFI_SSID "YOUR_WIFI_SSID"
#define WIFI_PASSWORD "YOUR_WIFI_PASSWORD"

// Pin Definitions
#define DHT_PIN 4
#define DHT_TYPE DHT22

// Display Settings
#define OLED_WIDTH 128
#define OLED_HEIGHT 64

// Update interval (ms)
#define UPDATE_INTERVAL 2000

#endif'''
        }
    ],
    "libraries": [
        {"name": "DHT sensor library", "version": "1.4.4", "manager": "Arduino Library Manager"},
        {"name": "Adafruit SSD1306", "version": "2.5.7", "manager": "Arduino Library Manager"},
        {"name": "Adafruit GFX Library", "version": "1.11.5", "manager": "Arduino Library Manager"}
    ],
    "wiring": [
        {"component": "DHT22", "pin": "VCC", "board_pin": "3.3V"},
        {"component": "DHT22", "pin": "GND", "board_pin": "GND"},
        {"component": "DHT22", "pin": "DATA", "board_pin": "GPIO4"},
        {"component": "OLED", "pin": "VCC", "board_pin": "3.3V"},
        {"component": "OLED", "pin": "GND", "board_pin": "GND"},
        {"component": "OLED", "pin": "SDA", "board_pin": "GPIO21"},
        {"component": "OLED", "pin": "SCL", "board_pin": "GPIO22"}
    ],
    "notes": "Install required libraries via Arduino Library Manager. Select ESP32 Dev Module as the board."
}


async def generate_code(
    project_description: str,
    board: str = "esp32",
    components: Optional[List[str]] = None,
    features: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Generate code for a project using Gemini AI.

    Args:
        project_description: Natural language description of the project
        board: Target board (esp32, esp8266, arduino-uno, etc.)
        components: List of components to use
        features: List of features to include (wifi, bluetooth, etc.)

    Returns:
        Dictionary with generated files, libraries, wiring, and notes
    """

    if not client:
        # Return mock response if no API key
        return MOCK_CODE_RESPONSE

    # Build the prompt
    board_info = BOARD_TEMPLATES.get(board, BOARD_TEMPLATES["esp32"])

    prompt = f"""
{SYSTEM_PROMPT}

## Project Specification

**Description:** {project_description}

**Target Board:** {board_info['name']}
- Features: {', '.join(board_info['features'])}
- Default I2C: SDA={board_info['default_pins']['i2c_sda']}, SCL={board_info['default_pins']['i2c_scl']}

**Components:** {', '.join(components) if components else 'Based on project description'}

**Required Features:** {', '.join(features) if features else 'Based on project description'}

Generate complete, production-ready code for this project. Return ONLY the JSON object, no markdown formatting.
"""

    try:
        response = client.models.generate_content(
            model=MODEL_NAME,
            contents=prompt
        )

        # Parse JSON from response
        response_text = response.text.strip()

        # Remove markdown code blocks if present
        if response_text.startswith("```"):
            lines = response_text.split("\n")
            response_text = "\n".join(lines[1:-1])

        try:
            result = json.loads(response_text)
            return result
        except json.JSONDecodeError:
            # If JSON parsing fails, return mock with note
            mock = MOCK_CODE_RESPONSE.copy()
            mock["notes"] = f"AI-generated code parsing failed. Showing template. Raw response available."
            mock["raw_response"] = response_text
            return mock

    except Exception as e:
        print(f"Code generation error: {e}")
        mock = MOCK_CODE_RESPONSE.copy()
        mock["notes"] = f"Code generation using AI failed: {str(e)}. Showing template code."
        return mock


def get_board_templates() -> Dict[str, Any]:
    """Get available board templates with their configurations."""
    return BOARD_TEMPLATES
